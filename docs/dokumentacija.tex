\documentclass[a4paper,12pt]{article}
%\usepackage[left=3cm,right=2cm,top=3cm,bottom=3cm,nohea dfoot]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[croatian]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{calc}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=black, filecolor=black, urlcolor=black, citecolor=black}
\usepackage{indentfirst}
\graphicspath{ {img/} }

\usepackage[nottoc, numbib, chapter]{tocbibind}
\usepackage[authoryear, round]{natbib}

\usepackage{booktabs}
\usepackage{mathpazo}
\pretolerance=150

\begin{document}

\begin{titlepage}
	\center
	
	\textsc{\Large SVEUČILIŠTE U ZAGREBU}\\
	\vspace{0.4cm}
	\textsc{\Large \textbf{FAKULTET ELEKTROTEHNIKE I RAČUNARSTVA}}
	\vspace{2.5cm}
	\vfill\vfill
    
	\textsc{\Large Projekt iz Bioinformatike}
	\vspace{0.5cm}
	
	{\huge\bfseries Računanje najduljeg zajedničkog prefiksa temeljeno na BWT}
	\vspace{1.2cm}
	
	\begin{minipage}{2.5\textwidth}
		\begin{flushleft}
			\large
			\textit{Autori}\\
			\textsc{Zvonimir Jurelinac, Tomislav Živec, Tonko Čupić}
		\end{flushleft}
	\end{minipage}

	\vspace{0.3cm}

	\begin{minipage}{2.5\textwidth}
		\begin{flushleft}
			\large
			\textit{Voditelj}\\
			doc.dr.sc \textsc{Mirjana Domazet- Lošo}
		\end{flushleft}
	\end{minipage}
	
	\vfill\vfill\vfill\vfill
	{\large Zagreb, prosinac 2017.}
		
\end{titlepage}

\newpage

\tableofcontents
\newpage

\section{Uvod}

Bioinformatika je grana znanosti koja usko povezuje biologiju i računarstvo, a ubrzano se razvijala zadnja dva desetljeća. Pojeftinjenje i sve veća dostupnost tehnologije sekvenciranja rezultirale su stvaranjem velikih skupova bioloških podataka. Često se kao zadatak u bioinformatici nameće analiza sekvence genoma. Pošto su te sekvence predugačke za uobičajenu pohranu i analizu, potrebno je koristiti posebna, prilagođene strukture podataka kao što su sufiksna polja i polja najdužih zajedničkih prefiksa. 

Cilj projekta je bio čim učinkovitije implementirati algoritme 1 i 2 iz rada \cite{beller2013}, koristeći pritom gotovu knjižnicu za izgradnju sufiksnog polja, te potom ostvarenu implementaciju usporediti s originalnom, ali i s rezultatima prošlogodišnjeg studentskog tima, koji su opisani u njihovu radu \cite{studenti2017}. Za usporedbu rezultata korišteni su sintetski podaci različitih duljina, kao i sekvenca genoma bakterije E. coli.

\newpage

\section{Algoritmi}
\textbf{TODO: Correct!}
U problemima analiza sekvenci vrlo često se javlja potreba za izračunom najduljeg zajedničkog prefiksa (LCP). U tu svrhu koriste sufiksni nizovi koji spremaju u listu spremaju sve moguće sufikse sekvence, od duljine 1 do najdulje. Iz sufiksnog niza dobiva se LCP polje u linearnom vremenu. 
Veliki resursni zahtjevi analize senkvenci DNK nameću zahtjeve za korištenjem podatkovnih struktura koje koriste manje memorijskog prostora. Iz te potrebe razvijeno je stablo valića niza transformiranog Burrows- Wheelerovom transformacijom (BWT).
Metoda je sljedeća: sekvenca se prvo podliježe Burrows- Wheelerovoj transformaciji, potom se transformirana sekvenca sprema u stablo valića. Stablo valića podržava pretraživanje unatrag po originalnom nizu pa tako dobivamo tražene sufikse. Opisani algoritam ima složenost $O(n\log\sigma)$, gdje je $\sigma$ veličina abecede.

\subsection{Podatkovne strukture}

\subsubsection{Sufiksno polje}
\textbf{TODO: Correct!}
Sufiksno polje sadrži sve sufikse od teksta S. Zamijenila je u toj zadaći sufiksno stablo jer koristi manje memorije od sufiksnog stabla za istu zadaću. Sufiksno polje se pokazalo kao vrlo važan alat u raspoznavanju i analizi teksta, bioinformatici i drugim primjenama. 
Sufiksno polje SA od niza znakova S je cjelobrojno polje u intervalu od 1 do n koje određuje leksikografski poredak svih n sufiksa niza znakova S. Preciznije, sufiksno polje zadovoljava $ S_{SA[1]} < S_{SA[2]} < ... < S_{SA[n]}$, gdje $ S_i $ označava i-ti sufiks niza znakova S, te sadrži znakove S[i..n].
 
\subsubsection{Burrows-Wheelerova transformacija (BWT)}
%\label{BWT_definicija}
Burrows- Wheelerova transformacija pretvara niz znakova u sličan niz znakova BWT[1..n] sa istom abecedom. Koristi se za kompresiju podataka. Transformacija je reverzibilna bez dodatnih resursnih zahtjeva. Elemente transformiranog niza računamo formulom:

$$
BWT[i]=
\begin{cases}
S[SA[i]-1], & \text{ako} \  SA[i]\neq 1\\ 
\$, & \text{inače}.
\end{cases}
$$
 
\begin{table}[h!]
	\caption{Pridruživanje indeksa sufiksima niza S, počevši od najduljeg.}
	\label{tablePrimjer1}
	\begin{center}
		\begin{tabular}{ll}
			\toprule
			i & S$_{SA}$[i] \\
			\midrule
			1 & abrakadabra\$ \\
			2 & brakadabra\$ \\
			3 & rakadabra\$ \\
			4 & akadabra\$ \\
			5 & kadabra\$ \\
			6 & adabra\$ \\
			7 & dabra\$ \\
			8 & abra\$ \\
			9 & bra\$ \\
			10 & ra\$ \\
			11 & a\$ \\
			12 & \$ \\
			\bottomrule
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!]
	\caption{Sufiksi su poredani leksikografski, a njihovi indeksi čine sufiksno polje SA.}
	\label{tablePrimjer2}
	\begin{center}
		\begin{tabular}{rrll}
			\toprule
			i & SA[i] & S$_{SA}$[i] & BWT[i] \\
			\midrule
			1 & 12 & \$ & a\\
			2 & 11 &  a\$ & r \\
			3 & 8 & abra\$ & d \\
			4 & 1 & abrakadabras\$ & \$ \\
			5 & 6 & adabra\$ & k \\
			6 & 4 & akadabra\$ & r \\
			7 & 9 & bra\$ & a\\
			8 & 2 & brakadabra\$ & a\\
			9 & 7 & dabra\$ & a \\
			10 & 5 & kadabra\$ & a\\
			11 & 10 & ra\$ & b \\
			12 & 3 & rakadabra\$ & b\\
			\bottomrule
		\end{tabular}
	\end{center}
\end{table}

\newpage

\subsubsection{Stablo valića}
\label{WT_defincija}

Stablo valića je struktura podataka koja rekurzivno particionira tok u 2 dijela sve dok su u svakom dijelu preostali homogeni podatci. Ime stabla je analogno valnoj transformaciji signala koji rekurzivno dekompresira signal prema frenkvencijama komponenti. 

Stablo valića može efikasno raditi upite rank i select nad nizovima proizvoljnih abeceda. To nam omogućuje pretraživanje unatrag u vremenskoj složenosti od  $O(\log\sigma)$ po koraku.
Prvo definiramo uzlazno poredanu abecedu $\eta$ kao niz znakova veličine $\sigma $.  
Zatim definiramo interval [1..r] kao podinterval abecede, r <= $\sigma$
Za interval [1..r], niz znakova BWT[1..r] dobijemo tako da iz transformiranog niza znakova od S uklonimo sve znakove iz B-W transformacije koji ne pripadaju segmentu abecede [1..r]

\section{Primjer rada algoritma}
U nastavku dokumenta dan je primjer rada algoritma na stringu S = mississippi.

\subsection{Izgradnja sufiksnog polja}

\begin{enumerate}
	\item Na kraj ulaznog niza dodaje se znak \$ te je sada S =  mississippi\$. U daljnjem tekstu vrijedi pretpostavka da je znak \$ abecedno manji od svih ostalih znakova od kojih je S izrađen.
	\item Svakom sufiksu niza S pridružuju se indeksi od 1 do \textit{n}, počevši od najduljeg. Ovo je prikazano u \textbf{tablici \ref{tableEx1}}

	\begin{table}[h!]
		\caption{Pridruživanje indeksa sufiksima niza S}
		\label{tableEx1}
		\begin{center}
			\begin{tabular}{ll}
				\toprule
				i & S$_{SA}$[i] \\
				\midrule
				1 & mississippi\$ \\
				2 & ississippi\$ \\
				3 & ssissippi\$ \\
				4 & sissippi\$ \\
				5 & issippi\$ \\
				6 & ssippi\$ \\
				7 & sippi\$ \\
				8 & ippi\$ \\
				9 & ppi\$ \\
				10 & pi\$ \\
				11 & i\$ \\
				12 & \$ \\
				\bottomrule
			\end{tabular}
		\end{center}
	\end{table}

	\item Sufiksno polje \(SA\) dobivamo soritiranjem dobivenih sufiksa leksikografski od najmanjeg prema najvećem. Ovo je prikazano u \textbf{tablici \ref{tableEx2}}.

	Dobiveno je sufiksno polje SA = [12, 11, 8, 5, 2, 1, 10, 9, 7, 4, 6, 3]

	\begin{table}[h!]
		\caption{Sufiksi su poredani leksikografski, a njihovi indeksi čine sufiksno polje SA.}
		\label{tablePrimjer3}
		\begin{center}
			\begin{tabular}{rrl}
				\toprule
				i & SA[i] & S$_{SA}$[i] \\
				\midrule
				1 & 12 & \$ \\
				2 & 11 &  i\$ \\
				3 & 8 & ippi\$ \\
				4 & 5 & issippi\$ \\
				5 & 2 & ississippi\$ \\
				6 & 1 & misssissippi\$ \\
				7 & 10 & pi\$ \\
				8 & 9 & ppi\$ \\
				9 & 7 & sippi\$ \\
				10 & 4 & sissippi\$ \\
				11 & 6 & ssippi\$ \\
				12 & 3 & ssissippi\$ \\
				\bottomrule
			\end{tabular}
		\end{center}
	\end{table}
\end{enumerate}

\subsection{Burrows-Wheelerova transformacija}

Izračunava se Burrows-Wheelerova transformacija BWT[1..n] za dobiveno sufiksno polje SA prema formuli navedenoj u \ref{BWT_defincija} .  
Npr. $$BWT[4]=S[SA[4]-1]=S[5-1]=S[4]=s.$$

Rezultat je prikazan u tablici \textbf{tablice \ref{tableEx3}}. 

\begin{table}[h!]
	\caption{Burrows-Wheelerova tranformacija}
	\label{tableEx3}
	\begin{center}
		\begin{tabular}{rrll}
			\toprule
			i & SA[i] & S$_{SA}$[i] & BWT[i] \\
			\midrule
			1 & 12 & \$ & i \\
			2 & 11 &  i\$ & p \\
			3 & 8 & ippi\$ & s \\
			4 & 5 & issippi\$ & s \\
			5 & 2 & ississippi\$ & m \\
			6 & 1 & misssissippi\$ & \$ \\
			7 & 10 & pi\$ & p \\
			8 & 9 & ppi\$ & i \\
			9 & 7 & sippi\$ & s \\
			10 & 4 & sissippi\$ & s \\
			11 & 6 & ssippi\$ & i \\
			12 & 3 & ssissippi\$ & i \\
			\bottomrule
		\end{tabular}
	\end{center}
\end{table}

\subsection{Izgradnja LCP niza}

\begin{enumerate}
	\item Iz dobivene Burrows-Wheelerove transformacije gradi se stablo valića opisanom u \ref{WT_definicija}. Prvo se stvara sortirana abeceda ulaznog niza koja je u ovom slučaju veličine 5 znakova ($\Sigma$[1..5]=\$imps). Korijen stabla čini bit vektor dobiven kodiranjem niza Burrows-Wheelerove transformacije dobivene u prethodnom koraku. Abeceda se potom dijeli na pola te dobivamo dva podniza, ovom slučaju: $\Sigma$[1..2]=\$i i $\Sigma$[3..5]=mps. Znakovi prve polovice u svakoj skupini kodiraju se vrijednošću 0, a ostali 1. Postupak se ponavlja sve dok se u čvoru ne nalaze samo jednaki znakovi koji čine listove stabla. Potpuno izgrađeno stablo za dani primjer prikazano je na slici \ref{fig:waveletTree}.

	\begin{figure}
		\begin{center}
			\includegraphics[width=\columnwidth]{waveletTree.png}
			\caption{Stablo valića za dani primjer}
			\label{fig:waveletTree}
		\end{center}
	\end{figure}


	\item Pomoću Algoritama 1 i 2 iz rada \cite{beller2013} gradi se polje najdužih zajedničkih prefiksa (LCP) u nekoliko koraka:
	\begin{enumerate}
		\item Inicijalizacija LCP polja i reda Q. Vrijednosti polja LCP se postavljaju na nevažeću (\textbf{$\perp$}) vrijednost, osim LCP[1] i LCP[n+1] koji se postavljaju na -1. U red Q stavljamo strukturu koja sadrži početni interval $I = [i..j]=[1..12]$ i broj $\textit{l}=0$:\\
	 	$$LCP = [-1,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp, \perp, -1]$$
		$$Q = [<[1..12],0>]$$
		\item Izračunavanje c$\omega$-intervala za interval dobiven uzimanjem elementa iz reda Q (FIFO) unutar funkcije \textit{getIntervals} iz Algoritma 1 \cite{beller2013}.
			\begin{itemize}
				\item \textit{c} - znak
				\item \textit{C[c]} - zbroj rangova svih elemenata leksikografski sortirane abecede koji su manji od c
			    \item \textit{i} - početak intervala
			    \item \textit{j} - kraj intervala
			    \item Funkcija \textit{rang(a,k)} vraća broj pojavljivanja znaka \textit{a} do \textit{k}-tog indeksa u polju. 
			    \item Znakovi abecede iz intervala $I$ se sortiraju od najmanjeg prema najvećem. Ima onoliko c$\omega$-intervala koliko je i jedinstvenih znakova. Kako je abeceda za dani primjer $\Sigma[1..5]=\$imps$, traži se 5 c$\omega$-intervala.
			    \item $C = [0,1,5,6,8]$
			    \item Indeks početka intervala dobiva se po formuli \textit{rang}(c,i-1)+C[c]+1 Indeks kraja intervala dobiva se po formuli C[c]+\textit{rang}(c,j).
			    \item U intervalu $I$ se nalaze svi znakovi abecede (\$,i,m,p,s). Za svaki od znakova računa se njegov interval prema formuli navedenoj iznad.
					  $$ [\textit{rang}('\$',0)+C['\$']+1..C['\$']+\textit{rang}('\$',12)]=[0+0+1..+0+1]=[1..1] $$
			    	  $$ [\textit{rang}('i',0)+C['i']+1..C['i']+\textit{rang}('i',12)]=[0+1+1..+1+4]=[2..5] $$
			    	  $$ [\textit{rang}('m',0)+C['m']+1..C['m']+\textit{rang}('m',12)]=[0+5+1..+5+1]=[6..6] $$
			    	  $$ [\textit{rang}('p',0)+C['p']+1..C['p']+\textit{rang}('p',12)]= [0+6+1..+6+2]=[7..8] $$
			          $$ [\textit{rang}('s',0)+C['s']+1..C['s']+\textit{rang}('s',12)]=[0+8+1..+8+4]=[9..12] $$
			    \item Povratna vrijednost \textit{getIntervals}, prema tome, je lista c$\omega$-intervala: [[1..1],[2..5],[6..6],[7..8],[9..12]]
				\item Za svaki od dobivenih intervala [\textit{lb .. rb}] se potom provjerava vrijednost LCP[\textit{rb}+1]. Ako je vrijednost tog polja \textbf{NULL} u red stavljamo strukturu [<[\textit{lb..rb}],\textit{l}+1>], a na index \textit{rb}+1 vrijednost \textit{l}. Navedeni postupak se ponavlja sve dok u redu ima elemenata, a prva dva koraka prikazana su u nastavku.
					\begin{enumerate}
						\item LCP = [-1,$\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp, \perp$, -1]
					    Q = [<[1..1],0>]
						[\textit{lb .. rb}] = [1..1], \textit{l} = 0
						\newline
						LCP[\textit{rb}+1]=LCP[2]=$\perp$ -> u red Q stavljamo strukturu [<[\textit{lb..rb}],\textit{l}+1>] = [<[\textit{1..1}],1>], a LCP[\textit{rb}+1]=LCP[2]=0.
						\item LCP = [-1,0,$\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp,\perp, \perp$, -1]
					   	Q = [<[2..5],0>,<[1..1],1>]
						[\textit{lb .. rb}] = [2..5], \textit{l} = 0
						\newline
						LCP[\textit{rb}+1]=LCP[6]=$\perp$ -> u red Q stavljamo strukturu [<[\textit{lb..rb}],\textit{l}+1>] = [<[\textit{2..5}],1>], a LCP[\textit{rb}+1]=LCP[6]=0.
						\item LCP = [-1,0,$\perp,\perp,\perp,$0$,\perp,\perp,\perp,\perp,\perp, \perp$, -1]
						Q = [<[6..6],0>,<[2..5],1>,<[1..1],1>]
						[\textit{lb .. rb}] = [6..6], \textit{l} = 0
						\newline (...)
					\end{enumerate}
	  	\end{itemize}
      	\item Vrijednost LCP polja koju dobijemo kao rezultat izvršavanja algoritma je: 
		LCP = [-1,0,1,1,4,0,0,1,0,2,1,3,-1].
	\end{enumerate}
\end{enumerate}


\section{Rezultati}


\begin{table}[h!]
	\caption{Rezultati usporedbe vremena izvođenja algoritama}
	\label{tableTimeComp}
	\begin{center}
		\begin{tabular}{rlll}
			\toprule
			Duljina & Prošlogodišnja & Originalna & Naša \\
			ulaza & implementacija & implementacija* & implementacija \\
			{[znak]} & [s] & [s] & [s] \\
			\midrule
			100.000	   	& 	0,04 	&	0,03		&	0,03 \\
			250.000		& 	0,16	&	0,12		&	0,09 \\
			500.000		& 	0,35	&	0,26		&	0,17 \\
			750.000		& 	0,53	&	0,40		&	0,26 \\
			1.000.000	& 	0,72	&	0,54		&	0,36 \\
			2.500.000	& 	1,99	&	1,49		&	1,06 \\
			4.639.675	& 	3,72	&	2,78		&	2,22 \\
			5.000.000	& 	4,1		&	3,06		&	2,46 \\
			7.500.000	& 	6,84	&	5,11		&	4,35 \\
			10.000.000	& 	9,27	&	6,92		&	6,38 \\
			12.500.000	& 	12,23	&	9,13		&	8,67 \\
			15.000.000	& 	14,89	&	11,12		&	10,63 \\
			17.500.000	& 	19,16	&	14,30		&	12,69 \\
			20.000.000	& 	21,6	&	16,13		&	15,2 \\
			\bottomrule
		\end{tabular}\\ ~ \\
		* \textit{Vrijednosti interpolirane na temelju rezultata prošlogodišnjeg rada}
	\end{center}
\end{table}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=\columnwidth]{timeGraph.png}
 		\caption{Grafički prikaz usporedbe vremena izvođenja različitih implementacija algoritama, prema podacima iz tablice \ref{tableTimeComp}. Sivom bojom prikazana je ovdje opisana implementacija.}
 		\label{fig:graphTime}
	\end{center}
\end{figure}


\begin{table}[h!]
	\caption{Rezultati usporedbe vremena izvođenja algoritama}
	\label{tableMemComp}
	\begin{center}
		\begin{tabular}{rlll}
			\toprule
			Duljina & Prošlogodišnja & Originalna & Naša \\
			ulaza & implementacija & implementacija* & implementacija \\
			{[znak]} & [MB] & [MB] & [MB] \\
			\midrule
			100.000     &   7,32    &   1,83    &   4,328   \\
			250.000     &   12,428  &   3,107   &   5,908   \\
			500.000     &   21,388  &   5,347   &   8,56    \\
			750.000     &   31,592  &   7,898   &   11,92   \\
			1.000.000   &   40,024  &   10,006  &   14,656  \\
			2.500.000   &   97,68   &   24,42   &   32,304  \\
			4.639.675   &   174,224 &   43,556  &   52,372  \\
			5.000.000   &   195,212 &   48,803  &   61,772  \\
			7.500.000   &   277,296 &   69,324  &   88,064  \\
			10.000.000  &   377,372 &   94,343  &   120,644 \\
			12.500.000  &   465,616 &   116,404 &   151,74  \\
			15.000.000  &   553,476 &   138,369 &   181,98  \\
			17.500.000  &   664,256 &   166,064 &   210,7   \\
			20.000.000  &   758,572 &   189,643 &   238,004 \\
			\bottomrule
		\end{tabular}\\ ~ \\
		* \textit{Vrijednosti interpolirane na temelju rezultata prošlogodišnjeg rada}
	\end{center}
\end{table}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=\columnwidth]{memoryGraph.png}
 		\caption{Grafički prikaz usporedbe memorijskog zauzeća različitih implementacija algoritama, prema podacima iz tablice \ref{tableMemComp}. Sivom bojom prikazana je ovdje opisana implementacija.}
 		\label{fig:graphMemory}
	\end{center}
\end{figure}

\section{Zaključak}

lalala

\newpage


\bibliography{literatura}
\bibliographystyle{fer}


\end{document}